class Solution {
    public static int SIZE = 100000;
    public static int[] p = new int[SIZE], stack= new int[SIZE], size = new int[SIZE];
    public static HashSet<Integer> set = new HashSet<>();
    public int find(int x) {
        int size = 0;
        while (x != p[x]) {
            stack[size++] = x;
            x = p[x];
        }
        while (size > 0) {
            p[stack[--size]] = x;
        }
        return x;
    }

    public boolean isSameSet(int x, int y) {
        return find(x) == find(y);
    }

    public void union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return;
        if (size[px] > size[py]) {
            size[px] += size[py];
            p[py] = px;
        } else {
            size[py] += size[px];
            p[px] = py;
        }
    }

    public int[] subArr(int[] p, int n) {
        int[] t = new int[n];
        for (int i = 0; i < n; i++) t[i] = p[i];
        return t;
    }
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        for (int i = 0; i < n; i++) {
            p[i] = i;
            size[i] = 1;
        }
        //set.add(0);set.add(firstPerson);
        Arrays.sort(meetings, (int[] x, int[] y) -> {return x[2] - y[2] == 0 
                                                        ? ( set.contains(x[1]) || set.contains(x[0])
                                                            ? -1 
                                                            : set.contains(y[1]) || set.contains(y[0])
                                                            ? 1
                                                            :0)
                                                        : x[2] - y[2];
                                                        });       
        union(firstPerson, 0);
        for (int i = 0; i < meetings.length;) {
            int[] m1 = meetings[i];
            int j = i;
            for (; j < meetings.length && meetings[j][2] == m1[2]; j++){
                union(meetings[j][0], meetings[j][1]);
            }
            for (int k = i; k < j && k < meetings.length; k++) {
                int[] m = meetings[k];
                if (find(m[0]) != find(0)) {p[m[0]] = m[0]; p[m[1]] = m[1];}
            }
            i = j;
        }
        List<Integer> xs = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (find(i) == find(0)) xs.add(i);
        }
        return xs;
    }
}
